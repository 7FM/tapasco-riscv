//
// Generated by Bluespec Compiler, version 2018.10.beta1 (build e1df8052c, 2018-10-17)
//
// On Thu Jul  4 10:53:49 CEST 2019
//
//
// Ports:
// Name                         I/O  size props
// rv_rstn                        O     1 reg
// rv_reset                       O     1 reg
// tapasco_intr                   O     1
// reqEN                          O     1
// resEN                          O     1 const
// saxi_arready                   O     1 reg
// saxi_rvalid                    O     1 reg
// saxi_rdata                     O    32
// saxi_rresp                     O     2
// saxi_awready                   O     1
// saxi_wready                    O     1
// saxi_bvalid                    O     1 reg
// saxi_bresp                     O     2
// CLK                            I     1 clock
// RST_N                          I     1 reset
// reqRDY_req_rdy                 I     1
// resRDY_res_rdy                 I     1 unused
// saxi_arvalid                   I     1
// saxi_araddr                    I    32 reg
// saxi_arprot                    I     3 reg
// saxi_rready                    I     1
// saxi_awvalid                   I     1
// saxi_awaddr                    I    32
// saxi_awprot                    I     3
// saxi_wvalid                    I     1
// saxi_wdata                     I    32
// saxi_wstrb                     I     4
// saxi_bready                    I     1
//
// Combinational paths from inputs to outputs:
//   reqRDY_req_rdy -> reqEN
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkRVController(CLK,
		      RST_N,

		      rv_rstn,

		      rv_reset,

		      tapasco_intr,

		      reqRDY_req_rdy,

		      resRDY_res_rdy,

		      reqEN,

		      resEN,

		      saxi_arready,

		      saxi_arvalid,

		      saxi_araddr,

		      saxi_arprot,

		      saxi_rvalid,

		      saxi_rready,

		      saxi_rdata,

		      saxi_rresp,

		      saxi_awready,

		      saxi_awvalid,

		      saxi_awaddr,

		      saxi_awprot,

		      saxi_wready,

		      saxi_wvalid,

		      saxi_wdata,

		      saxi_wstrb,

		      saxi_bvalid,

		      saxi_bready,

		      saxi_bresp);
  input  CLK;
  input  RST_N;

  // value method rv_rstn
  output rv_rstn;

  // value method rv_reset
  output rv_reset;

  // value method tapasco_intr
  output tapasco_intr;

  // action method reqRDY
  input  reqRDY_req_rdy;

  // action method resRDY
  input  resRDY_res_rdy;

  // value method reqEN
  output reqEN;

  // value method resEN
  output resEN;

  // value method saxi_rd_arready
  output saxi_arready;

  // action method saxi_rd_parvalid
  input  saxi_arvalid;

  // action method saxi_rd_paraddr
  input  [31 : 0] saxi_araddr;

  // action method saxi_rd_parprot
  input  [2 : 0] saxi_arprot;

  // value method saxi_rd_rvalid
  output saxi_rvalid;

  // action method saxi_rd_prready
  input  saxi_rready;

  // value method saxi_rd_rdata
  output [31 : 0] saxi_rdata;

  // value method saxi_rd_rresp
  output [1 : 0] saxi_rresp;

  // value method saxi_wr_awready
  output saxi_awready;

  // action method saxi_wr_pawvalid
  input  saxi_awvalid;

  // action method saxi_wr_pawaddr
  input  [31 : 0] saxi_awaddr;

  // action method saxi_wr_pawprot
  input  [2 : 0] saxi_awprot;

  // value method saxi_wr_wready
  output saxi_wready;

  // action method saxi_wr_pwvalid
  input  saxi_wvalid;

  // action method saxi_wr_pwdata
  input  [31 : 0] saxi_wdata;

  // action method saxi_wr_pwstrb
  input  [3 : 0] saxi_wstrb;

  // value method saxi_wr_bvalid
  output saxi_bvalid;

  // action method saxi_wr_pbready
  input  saxi_bready;

  // value method saxi_wr_bresp
  output [1 : 0] saxi_bresp;

  // signals for module outputs
  wire [31 : 0] saxi_rdata;
  wire [1 : 0] saxi_bresp, saxi_rresp;
  wire reqEN,
       resEN,
       rv_reset,
       rv_rstn,
       saxi_arready,
       saxi_awready,
       saxi_bvalid,
       saxi_rvalid,
       saxi_wready,
       tapasco_intr;

  // inlined wires
  wire [36 : 0] wr_s_dataIn_rv$port0__write_1,
		wr_s_dataIn_rv$port1__read,
		wr_s_dataIn_rv$port2__read;
  wire [35 : 0] wr_s_addrIn_rv$port0__write_1,
		wr_s_addrIn_rv$port1__read,
		wr_s_addrIn_rv$port2__read;
  wire wr_s_addrIn_rv$EN_port0__write,
       wr_s_addrIn_rv$EN_port1__write,
       wr_s_dataIn_rv$EN_port0__write,
       wr_s_dataIn_rv$EN_port1__write;

  // register arg0
  reg [31 : 0] arg0;
  wire [31 : 0] arg0$D_IN;
  wire arg0$EN;

  // register arg1
  reg [31 : 0] arg1;
  wire [31 : 0] arg1$D_IN;
  wire arg1$EN;

  // register arg2
  reg [31 : 0] arg2;
  wire [31 : 0] arg2$D_IN;
  wire arg2$EN;

  // register arg3
  reg [31 : 0] arg3;
  wire [31 : 0] arg3$D_IN;
  wire arg3$EN;

  // register arg4
  reg [31 : 0] arg4;
  wire [31 : 0] arg4$D_IN;
  wire arg4$EN;

  // register counter
  reg [63 : 0] counter;
  wire [63 : 0] counter$D_IN;
  wire counter$EN;

  // register ctrl
  reg ctrl;
  wire ctrl$D_IN, ctrl$EN;

  // register grace
  reg [6 : 0] grace;
  reg [6 : 0] grace$D_IN;
  wire grace$EN;

  // register resetBSV
  reg resetBSV;
  wire resetBSV$D_IN, resetBSV$EN;

  // register ret
  reg [63 : 0] ret;
  wire [63 : 0] ret$D_IN;
  wire ret$EN;

  // register rst
  reg rst;
  wire rst$D_IN, rst$EN;

  // register rstn
  reg rstn;
  wire rstn$D_IN, rstn$EN;

  // register wr_s_addrIn_rv
  reg [35 : 0] wr_s_addrIn_rv;
  wire [35 : 0] wr_s_addrIn_rv$D_IN;
  wire wr_s_addrIn_rv$EN;

  // register wr_s_dataIn_rv
  reg [36 : 0] wr_s_dataIn_rv;
  wire [36 : 0] wr_s_dataIn_rv$D_IN;
  wire wr_s_dataIn_rv$EN;

  // ports of submodule rd_s_in
  wire [34 : 0] rd_s_in$D_IN, rd_s_in$D_OUT;
  wire rd_s_in$CLR, rd_s_in$DEQ, rd_s_in$EMPTY_N, rd_s_in$ENQ, rd_s_in$FULL_N;

  // ports of submodule rd_s_out
  reg [33 : 0] rd_s_out$D_IN;
  wire [33 : 0] rd_s_out$D_OUT;
  wire rd_s_out$CLR,
       rd_s_out$DEQ,
       rd_s_out$EMPTY_N,
       rd_s_out$ENQ,
       rd_s_out$FULL_N;

  // ports of submodule wr_s_in
  wire [70 : 0] wr_s_in$D_IN, wr_s_in$D_OUT;
  wire wr_s_in$CLR, wr_s_in$DEQ, wr_s_in$EMPTY_N, wr_s_in$ENQ, wr_s_in$FULL_N;

  // ports of submodule wr_s_out
  wire [1 : 0] wr_s_out$D_IN, wr_s_out$D_OUT;
  wire wr_s_out$CLR,
       wr_s_out$DEQ,
       wr_s_out$EMPTY_N,
       wr_s_out$ENQ,
       wr_s_out$FULL_N;

  // rule scheduling signals
  wire WILL_FIRE_RL_graceDown,
       WILL_FIRE_RL_handle_start,
       WILL_FIRE_RL_handle_write,
       WILL_FIRE_RL_resetAll;

  // inputs to muxes for submodule ports
  wire [63 : 0] MUX_counter$write_1__VAL_2;
  wire [6 : 0] MUX_grace$write_1__VAL_3;
  wire MUX_ctrl$write_1__SEL_1,
       MUX_grace$write_1__SEL_1,
       MUX_resetBSV$write_1__SEL_2;

  // remaining internal signals
  wire [63 : 0] x__h3652, x__h3717;
  wire [31 : 0] x_data__h3280;
  wire NOT_wr_s_in_first__03_BITS_6_TO_3_04_EQ_0_05_0_ETC___d135;

  // value method rv_rstn
  assign rv_rstn = rstn ;

  // value method rv_reset
  assign rv_reset = rst ;

  // value method tapasco_intr
  assign tapasco_intr = MUX_grace$write_1__SEL_1 ;

  // value method reqEN
  assign reqEN = MUX_resetBSV$write_1__SEL_2 ;

  // value method resEN
  assign resEN = 1'b0 ;

  // value method saxi_rd_arready
  assign saxi_arready = rd_s_in$FULL_N ;

  // value method saxi_rd_rvalid
  assign saxi_rvalid = rd_s_out$EMPTY_N ;

  // value method saxi_rd_rdata
  assign saxi_rdata = rd_s_out$EMPTY_N ? rd_s_out$D_OUT[33:2] : 32'd0 ;

  // value method saxi_rd_rresp
  assign saxi_rresp = rd_s_out$EMPTY_N ? rd_s_out$D_OUT[1:0] : 2'd0 ;

  // value method saxi_wr_awready
  assign saxi_awready = !wr_s_addrIn_rv[35] ;

  // value method saxi_wr_wready
  assign saxi_wready = !wr_s_dataIn_rv[36] ;

  // value method saxi_wr_bvalid
  assign saxi_bvalid = wr_s_out$EMPTY_N ;

  // value method saxi_wr_bresp
  assign saxi_bresp = wr_s_out$EMPTY_N ? wr_s_out$D_OUT : 2'd0 ;

  // submodule rd_s_in
  SizedFIFO #(.p1width(32'd35),
	      .p2depth(32'd8),
	      .p3cntr_width(32'd3),
	      .guarded(32'd1)) rd_s_in(.RST(RST_N),
				       .CLK(CLK),
				       .D_IN(rd_s_in$D_IN),
				       .ENQ(rd_s_in$ENQ),
				       .DEQ(rd_s_in$DEQ),
				       .CLR(rd_s_in$CLR),
				       .D_OUT(rd_s_in$D_OUT),
				       .FULL_N(rd_s_in$FULL_N),
				       .EMPTY_N(rd_s_in$EMPTY_N));

  // submodule rd_s_out
  SizedFIFO #(.p1width(32'd34),
	      .p2depth(32'd8),
	      .p3cntr_width(32'd3),
	      .guarded(32'd1)) rd_s_out(.RST(RST_N),
					.CLK(CLK),
					.D_IN(rd_s_out$D_IN),
					.ENQ(rd_s_out$ENQ),
					.DEQ(rd_s_out$DEQ),
					.CLR(rd_s_out$CLR),
					.D_OUT(rd_s_out$D_OUT),
					.FULL_N(rd_s_out$FULL_N),
					.EMPTY_N(rd_s_out$EMPTY_N));

  // submodule wr_s_in
  SizedFIFO #(.p1width(32'd71),
	      .p2depth(32'd8),
	      .p3cntr_width(32'd3),
	      .guarded(32'd1)) wr_s_in(.RST(RST_N),
				       .CLK(CLK),
				       .D_IN(wr_s_in$D_IN),
				       .ENQ(wr_s_in$ENQ),
				       .DEQ(wr_s_in$DEQ),
				       .CLR(wr_s_in$CLR),
				       .D_OUT(wr_s_in$D_OUT),
				       .FULL_N(wr_s_in$FULL_N),
				       .EMPTY_N(wr_s_in$EMPTY_N));

  // submodule wr_s_out
  SizedFIFO #(.p1width(32'd2),
	      .p2depth(32'd8),
	      .p3cntr_width(32'd3),
	      .guarded(32'd1)) wr_s_out(.RST(RST_N),
					.CLK(CLK),
					.D_IN(wr_s_out$D_IN),
					.ENQ(wr_s_out$ENQ),
					.DEQ(wr_s_out$DEQ),
					.CLR(wr_s_out$CLR),
					.D_OUT(wr_s_out$D_OUT),
					.FULL_N(wr_s_out$FULL_N),
					.EMPTY_N(wr_s_out$EMPTY_N));

  // rule RL_graceDown
  assign WILL_FIRE_RL_graceDown = grace > 7'd1 ;

  // rule RL_handle_start
  assign WILL_FIRE_RL_handle_start = ctrl && rst ;

  // rule RL_resetAll
  assign WILL_FIRE_RL_resetAll = grace == 7'd1 && !WILL_FIRE_RL_handle_write ;

  // rule RL_handle_write
  assign WILL_FIRE_RL_handle_write = wr_s_in$EMPTY_N && wr_s_out$FULL_N ;

  // inputs to muxes for submodule ports
  assign MUX_ctrl$write_1__SEL_1 =
	     WILL_FIRE_RL_handle_write && wr_s_in$D_OUT[6:3] != 4'd0 &&
	     wr_s_in$D_OUT[54:39] == 16'h0 ;
  assign MUX_grace$write_1__SEL_1 =
	     WILL_FIRE_RL_handle_write &&
	     NOT_wr_s_in_first__03_BITS_6_TO_3_04_EQ_0_05_0_ETC___d135 ;
  assign MUX_resetBSV$write_1__SEL_2 = resetBSV && reqRDY_req_rdy ;
  assign MUX_counter$write_1__VAL_2 = counter + 64'd1 ;
  assign MUX_grace$write_1__VAL_3 = grace - 7'd1 ;

  // inlined wires
  assign wr_s_addrIn_rv$EN_port0__write =
	     !wr_s_addrIn_rv[35] && saxi_awvalid ;
  assign wr_s_addrIn_rv$port0__write_1 = { 1'd1, saxi_awaddr, saxi_awprot } ;
  assign wr_s_addrIn_rv$port1__read =
	     wr_s_addrIn_rv$EN_port0__write ?
	       wr_s_addrIn_rv$port0__write_1 :
	       wr_s_addrIn_rv ;
  assign wr_s_addrIn_rv$EN_port1__write =
	     wr_s_addrIn_rv$port1__read[35] &&
	     wr_s_dataIn_rv$port1__read[36] &&
	     wr_s_in$FULL_N ;
  assign wr_s_addrIn_rv$port2__read =
	     wr_s_addrIn_rv$EN_port1__write ?
	       36'h2AAAAAAAA :
	       wr_s_addrIn_rv$port1__read ;
  assign wr_s_dataIn_rv$EN_port0__write = !wr_s_dataIn_rv[36] && saxi_wvalid ;
  assign wr_s_dataIn_rv$port0__write_1 = { 1'd1, saxi_wdata, saxi_wstrb } ;
  assign wr_s_dataIn_rv$port1__read =
	     wr_s_dataIn_rv$EN_port0__write ?
	       wr_s_dataIn_rv$port0__write_1 :
	       wr_s_dataIn_rv ;
  assign wr_s_dataIn_rv$EN_port1__write =
	     wr_s_addrIn_rv$port1__read[35] &&
	     wr_s_dataIn_rv$port1__read[36] &&
	     wr_s_in$FULL_N ;
  assign wr_s_dataIn_rv$port2__read =
	     wr_s_dataIn_rv$EN_port1__write ?
	       37'h0AAAAAAAAA :
	       wr_s_dataIn_rv$port1__read ;

  // register arg0
  assign arg0$D_IN = wr_s_in$D_OUT[38:7] ;
  assign arg0$EN =
	     WILL_FIRE_RL_handle_write && wr_s_in$D_OUT[6:3] != 4'd0 &&
	     wr_s_in$D_OUT[54:39] == 16'h0020 ;

  // register arg1
  assign arg1$D_IN = wr_s_in$D_OUT[38:7] ;
  assign arg1$EN =
	     WILL_FIRE_RL_handle_write && wr_s_in$D_OUT[6:3] != 4'd0 &&
	     wr_s_in$D_OUT[54:39] == 16'h0030 ;

  // register arg2
  assign arg2$D_IN = wr_s_in$D_OUT[38:7] ;
  assign arg2$EN =
	     WILL_FIRE_RL_handle_write && wr_s_in$D_OUT[6:3] != 4'd0 &&
	     wr_s_in$D_OUT[54:39] == 16'h0040 ;

  // register arg3
  assign arg3$D_IN = wr_s_in$D_OUT[38:7] ;
  assign arg3$EN =
	     WILL_FIRE_RL_handle_write && wr_s_in$D_OUT[6:3] != 4'd0 &&
	     wr_s_in$D_OUT[54:39] == 16'h0050 ;

  // register arg4
  assign arg4$D_IN = wr_s_in$D_OUT[38:7] ;
  assign arg4$EN =
	     WILL_FIRE_RL_handle_write && wr_s_in$D_OUT[6:3] != 4'd0 &&
	     wr_s_in$D_OUT[54:39] == 16'h0060 ;

  // register counter
  assign counter$D_IN =
	     WILL_FIRE_RL_handle_start ? 64'd0 : MUX_counter$write_1__VAL_2 ;
  assign counter$EN = rstn || WILL_FIRE_RL_handle_start ;

  // register ctrl
  assign ctrl$D_IN = MUX_ctrl$write_1__SEL_1 && wr_s_in$D_OUT[38:7] != 32'd0 ;
  assign ctrl$EN =
	     WILL_FIRE_RL_handle_write && wr_s_in$D_OUT[6:3] != 4'd0 &&
	     wr_s_in$D_OUT[54:39] == 16'h0 ||
	     WILL_FIRE_RL_resetAll ;

  // register grace
  always@(MUX_grace$write_1__SEL_1 or
	  WILL_FIRE_RL_resetAll or
	  WILL_FIRE_RL_graceDown or MUX_grace$write_1__VAL_3)
  case (1'b1)
    MUX_grace$write_1__SEL_1: grace$D_IN = 7'd120;
    WILL_FIRE_RL_resetAll: grace$D_IN = 7'd0;
    WILL_FIRE_RL_graceDown: grace$D_IN = MUX_grace$write_1__VAL_3;
    default: grace$D_IN = 7'b0101010 /* unspecified value */ ;
  endcase
  assign grace$EN =
	     WILL_FIRE_RL_handle_write &&
	     NOT_wr_s_in_first__03_BITS_6_TO_3_04_EQ_0_05_0_ETC___d135 ||
	     WILL_FIRE_RL_graceDown ||
	     WILL_FIRE_RL_resetAll ;

  // register resetBSV
  assign resetBSV$D_IN = WILL_FIRE_RL_handle_start ;
  assign resetBSV$EN =
	     resetBSV && reqRDY_req_rdy || WILL_FIRE_RL_handle_start ;

  // register ret
  assign ret$D_IN = (wr_s_in$D_OUT[54:39] == 16'h0010) ? x__h3652 : x__h3717 ;
  assign ret$EN =
	     WILL_FIRE_RL_handle_write && wr_s_in$D_OUT[6:3] != 4'd0 &&
	     (wr_s_in$D_OUT[54:39] == 16'h0010 ||
	      wr_s_in$D_OUT[54:39] == 16'h0014) ;

  // register rst
  assign rst$D_IN = WILL_FIRE_RL_resetAll ;
  assign rst$EN = WILL_FIRE_RL_handle_start || WILL_FIRE_RL_resetAll ;

  // register rstn
  assign rstn$D_IN = !WILL_FIRE_RL_resetAll ;
  assign rstn$EN = WILL_FIRE_RL_resetAll || WILL_FIRE_RL_handle_start ;

  // register wr_s_addrIn_rv
  assign wr_s_addrIn_rv$D_IN = wr_s_addrIn_rv$port2__read ;
  assign wr_s_addrIn_rv$EN = 1'b1 ;

  // register wr_s_dataIn_rv
  assign wr_s_dataIn_rv$D_IN = wr_s_dataIn_rv$port2__read ;
  assign wr_s_dataIn_rv$EN = 1'b1 ;

  // submodule rd_s_in
  assign rd_s_in$D_IN = { saxi_araddr, saxi_arprot } ;
  assign rd_s_in$ENQ = rd_s_in$FULL_N && saxi_arvalid ;
  assign rd_s_in$DEQ = rd_s_in$EMPTY_N && rd_s_out$FULL_N ;
  assign rd_s_in$CLR = 1'b0 ;

  // submodule rd_s_out
  always@(rd_s_in$D_OUT or
	  x_data__h3280 or
	  ret or arg0 or arg1 or arg2 or arg3 or arg4 or counter)
  begin
    case (rd_s_in$D_OUT[10:3])
      8'h0: rd_s_out$D_IN = { x_data__h3280, 2'd0 };
      8'h10: rd_s_out$D_IN = { ret[31:0], 2'd0 };
      8'h14: rd_s_out$D_IN = { ret[63:32], 2'd0 };
      8'h20: rd_s_out$D_IN = { arg0, 2'd0 };
      8'h30: rd_s_out$D_IN = { arg1, 2'd0 };
      8'h40: rd_s_out$D_IN = { arg2, 2'd0 };
      8'h50: rd_s_out$D_IN = { arg3, 2'd0 };
      8'h60: rd_s_out$D_IN = { arg4, 2'd0 };
      8'h70: rd_s_out$D_IN = { counter[31:0], 2'd0 };
      8'h74: rd_s_out$D_IN = { counter[63:32], 2'd0 };
      default: rd_s_out$D_IN = 34'd0;
    endcase
  end
  assign rd_s_out$ENQ = rd_s_in$EMPTY_N && rd_s_out$FULL_N ;
  assign rd_s_out$DEQ = rd_s_out$EMPTY_N && saxi_rready ;
  assign rd_s_out$CLR = 1'b0 ;

  // submodule wr_s_in
  assign wr_s_in$D_IN =
	     { wr_s_addrIn_rv$port1__read[34:3],
	       wr_s_dataIn_rv$port1__read[35:0],
	       wr_s_addrIn_rv$port1__read[2:0] } ;
  assign wr_s_in$ENQ =
	     wr_s_addrIn_rv$port1__read[35] &&
	     wr_s_dataIn_rv$port1__read[36] &&
	     wr_s_in$FULL_N ;
  assign wr_s_in$DEQ = WILL_FIRE_RL_handle_write ;
  assign wr_s_in$CLR = 1'b0 ;

  // submodule wr_s_out
  assign wr_s_out$D_IN = 2'd0 ;
  assign wr_s_out$ENQ = WILL_FIRE_RL_handle_write ;
  assign wr_s_out$DEQ = wr_s_out$EMPTY_N && saxi_bready ;
  assign wr_s_out$CLR = 1'b0 ;

  // remaining internal signals
  assign NOT_wr_s_in_first__03_BITS_6_TO_3_04_EQ_0_05_0_ETC___d135 =
	     wr_s_in$D_OUT[6:3] != 4'd0 && wr_s_in$D_OUT[54:39] == 16'h4000 &&
	     ctrl &&
	     wr_s_in$D_OUT[38:7] != 32'd0 ;
  assign x__h3652 = { ret[63:32], wr_s_in$D_OUT[38:7] } ;
  assign x__h3717 = { wr_s_in$D_OUT[38:7], ret[31:0] } ;
  assign x_data__h3280 = ctrl ? 32'd1 : 32'd0 ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        arg0 <= `BSV_ASSIGNMENT_DELAY 32'd0;
	arg1 <= `BSV_ASSIGNMENT_DELAY 32'd0;
	arg2 <= `BSV_ASSIGNMENT_DELAY 32'd0;
	arg3 <= `BSV_ASSIGNMENT_DELAY 32'd0;
	arg4 <= `BSV_ASSIGNMENT_DELAY 32'd0;
	counter <= `BSV_ASSIGNMENT_DELAY 64'd0;
	ctrl <= `BSV_ASSIGNMENT_DELAY 1'd0;
	grace <= `BSV_ASSIGNMENT_DELAY 7'd0;
	resetBSV <= `BSV_ASSIGNMENT_DELAY 1'd0;
	ret <= `BSV_ASSIGNMENT_DELAY 64'd0;
	rst <= `BSV_ASSIGNMENT_DELAY 1'd1;
	rstn <= `BSV_ASSIGNMENT_DELAY 1'd0;
	wr_s_addrIn_rv <= `BSV_ASSIGNMENT_DELAY 36'h2AAAAAAAA;
	wr_s_dataIn_rv <= `BSV_ASSIGNMENT_DELAY 37'h0AAAAAAAAA;
      end
    else
      begin
        if (arg0$EN) arg0 <= `BSV_ASSIGNMENT_DELAY arg0$D_IN;
	if (arg1$EN) arg1 <= `BSV_ASSIGNMENT_DELAY arg1$D_IN;
	if (arg2$EN) arg2 <= `BSV_ASSIGNMENT_DELAY arg2$D_IN;
	if (arg3$EN) arg3 <= `BSV_ASSIGNMENT_DELAY arg3$D_IN;
	if (arg4$EN) arg4 <= `BSV_ASSIGNMENT_DELAY arg4$D_IN;
	if (counter$EN) counter <= `BSV_ASSIGNMENT_DELAY counter$D_IN;
	if (ctrl$EN) ctrl <= `BSV_ASSIGNMENT_DELAY ctrl$D_IN;
	if (grace$EN) grace <= `BSV_ASSIGNMENT_DELAY grace$D_IN;
	if (resetBSV$EN) resetBSV <= `BSV_ASSIGNMENT_DELAY resetBSV$D_IN;
	if (ret$EN) ret <= `BSV_ASSIGNMENT_DELAY ret$D_IN;
	if (rst$EN) rst <= `BSV_ASSIGNMENT_DELAY rst$D_IN;
	if (rstn$EN) rstn <= `BSV_ASSIGNMENT_DELAY rstn$D_IN;
	if (wr_s_addrIn_rv$EN)
	  wr_s_addrIn_rv <= `BSV_ASSIGNMENT_DELAY wr_s_addrIn_rv$D_IN;
	if (wr_s_dataIn_rv$EN)
	  wr_s_dataIn_rv <= `BSV_ASSIGNMENT_DELAY wr_s_dataIn_rv$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    arg0 = 32'hAAAAAAAA;
    arg1 = 32'hAAAAAAAA;
    arg2 = 32'hAAAAAAAA;
    arg3 = 32'hAAAAAAAA;
    arg4 = 32'hAAAAAAAA;
    counter = 64'hAAAAAAAAAAAAAAAA;
    ctrl = 1'h0;
    grace = 7'h2A;
    resetBSV = 1'h0;
    ret = 64'hAAAAAAAAAAAAAAAA;
    rst = 1'h0;
    rstn = 1'h0;
    wr_s_addrIn_rv = 36'hAAAAAAAAA;
    wr_s_dataIn_rv = 37'h0AAAAAAAAA;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on

  // handling of system tasks

  // synopsys translate_off
  always@(negedge CLK)
  begin
    #0;
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_resetAll) $display("BOOM reset");
  end
  // synopsys translate_on
endmodule  // mkRVController

